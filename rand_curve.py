#!/usr/bin/env python

__doc__ = '''
2D Rand Error Between Segmentations (pyws vs znn_volume)

 This module computes the 2D Rand Error between
a watershed h5 file (as generated by spipe) and a comparison set of labels. 
It derives the thresholded version of the dendrogram over a specified range,
and then finds the rand_error for each thresholded segmentation.

The module can save the curve of errors to disk and/or plot the curve to the
screen

Inputs:

	-pyws h5 filename
	-Comparison Label Filename
	-Lower bound on thresholds 
	  (opt, default=0.5)
	-Upper bound on thresholds 
	  (opt, default=0.9)
	-Number of desired thresholds 
	  (opt, default=41)
	
Main Outputs:

	-Plots the curve to the screen (unless -no_draw provided)
	-Saves the error values to disk (when -outname provided)

Nicholas Turner, July 2015
'''
import argparse
import h5py

import numpy as np
import scipy.sparse as sp #represents the dendrogram as a sparse mat
import matplotlib.pylab as plt # for plotting the curve

import emio
from volume_util import crop #This SHOULD be unnecessary, but could be useful
from cynn import relabel
from rand_error import seg_fr_rand_error

def import_data(h5filename):
	'''Imports a h5 pyws segmentation file'''
	f = h5py.File(h5filename)

	#conversion to explicit np array necessary for later np functions
	seg = np.array(f['/main'])
	dend_pairs = f['/dend']
	dend_values = f['/dendValues']

	return seg, dend_pairs, dend_values

def import_comparison(filename):
	return emio.znn_img_read(filename)

def generate_thresholds(thr_low, thr_high, num_thresholds):
	return np.linspace(thr_low, thr_high, num_thresholds)

def threshold_dendrogram(dend_pairs, dend_values, thr):
	'''Derives a thresholded sparse matrix (coo_matrix) from the dendrogram'''

	num_segments = np.max(dend_pairs) + 1

	# Making the matrix symmetric
	all_rows = np.concatenate((dend_pairs[0,:], dend_pairs[1,:]))
	all_cols = np.concatenate((dend_pairs[1,:], dend_pairs[0,:]))
	all_data = np.concatenate((dend_values    , dend_values    ))

	rows = all_rows[all_data > thr]
	cols = all_cols[all_data > thr]
	data = all_data[all_data > thr]

	return sp.coo_matrix((data, (rows, cols)),
							shape=(num_segments, num_segments))

def relabel_dendrogram(thr_dendrogram):	
	'''Determines a new labelling of the dendrogram which merges segments
	with affinity values greater than the threshold 
	(by surviving links in the thresholded dendrogram)'''

	num_segments = thr_dendrogram.shape[0]

	relabelling = np.array([-1 for seg in range(num_segments)])

	next_label = 1
	for seg in range(num_segments):

		if relabelling[seg] != -1:
			continue

		merged_to_seg = sp.csgraph.depth_first_order(thr_dendrogram, seg)[0]

		relabelling[merged_to_seg] = next_label
		next_label += 1

	return relabelling.astype('uint32')

def relabel_at_threshold(seg, thresh, dend_pairs, dend_values):
	'''Slightly high-level function which thresholds a dendrogram and
	relabels it accordingly'''

	thr_dendrogram = threshold_dendrogram(dend_pairs, dend_values, thresh)

	relabelling = relabel_dendrogram(thr_dendrogram)

	return relabel.relabel_segmentation(seg, relabelling)

def draw_curve(errors, thresholds):
	'''Draws the resulting curve of the rand_error over the different
	values of the threshold'''

	plt.plot(thresholds, errors)

	plt.xlabel('Thresholds')
	plt.ylabel('Error')
	plt.show()

def save_errors(errors, outname, thr_high, thr_low, num_thresholds):
	'''Saves the rand_error values to disk under the following convention

	${outname/prefix}_${thr_low}_${thr_high}_${num_thresholds}'''

	final_name = "%s_%g_%g_%d" % (outname, thr_low, thr_high, num_thresholds)

	errors = np.array(errors)

	errors.tofile(final_name)

def main(wsmerge_filename, comparison_filename, thr_low, thr_high, 
	num_thresholds=10, draw=False, outname=None):

	print "Importing Data..."
	seg, dend_pairs, dend_values = import_data(wsmerge_filename)
	comp_seg = import_comparison(comparison_filename).astype('uint32')

	print "Cropping comparison segmentation..."
	comp_seg = crop(comp_seg, seg.shape)

	print "Finding thresholds..."
	thresholds = generate_thresholds(thr_low, thr_high, num_thresholds)

	print "Calculating error curve..."
	full_errors = []
	merge_errors = []
	split_errors = []
	for thresh in thresholds:
		print "Thresh: %g" % thresh

		relabelled_seg = relabel_at_threshold(seg, thresh, dend_pairs, dend_values)

		full, merge, split = seg_fr_rand_error(relabelled_seg, comp_seg, 
								merge_err=True, 
								split_err=True)

		full_errors.append(full)
		merge_errors.append(merge)
		split_errors.append(split)

	if draw:
		print "Drawing Curve..."
		draw_curve(full_errors, thresholds)

	if outname != None:
		print "Saving Errors..."
		save_errors(full_errors, outname + '_full',
				thr_high, thr_low, num_thresholds)
		save_errors(merge_errors, outname + '_merge',
				thr_high, thr_low, num_thresholds)
		save_errors(split_errors, outname + '_split',
				thr_high, thr_low, num_thresholds)

		return full_errors, thresholds

if __name__ == '__main__':

	parser = argparse.ArgumentParser(
		description=__doc__,
		formatter_class=argparse.RawDescriptionHelpFormatter)

	parser.add_argument('ws_filename', 
		help="Filename of the watershed h5 file")
	parser.add_argument('label_filename',
		help="Filename of the labels for comparison")
	parser.add_argument('thr_low',
		nargs='?',default=0.5, type=float,
		help="Low bound on thresholds")
	parser.add_argument('thr_high',
		nargs='?',default=0.9, type=float,
		help="High bound on thresholds")
	parser.add_argument('num_thresholds',
		nargs='?',default=41, type=int,
		help="Number of thresholds")
	parser.add_argument('-no_draw',
		default=True, action='store_false')
	parser.add_argument('-outname',
		default=None)

	args = parser.parse_args()

	main(args.ws_filename,
		 args.label_filename,
		 args.thr_low,
		 args.thr_high,
		 args.num_thresholds,
		 args.no_draw,
		 args.outname)
